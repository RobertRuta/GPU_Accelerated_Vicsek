// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateParticles
#pragma kernel UpdateGrid

#define THREAD_GROUPS 128
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Particle
{
    float4 position;
    float4 velocity;
};

RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<uint> particle_ids;
RWStructuredBuffer<uint> grid_ids;

Texture2D NoiseTexture;

SamplerState samplerNoiseTexture;


float deltaTime;
float time;
float radius;
float noise;
float speed;
int numParticles;
uint rng_state;

float3 box;
uint3 grid_dims;


// Binds particles to box. If particle leaves box it is teleported to other side.
float3 BoundToBox(float3 pos)
{
    [branch] if(pos.x > box.x)
    {
       pos.x -= box.x;
    }
    [branch] if(pos.x < 0.0)
    {
        pos.x += box.x;
    }
    [branch] if(pos.y > box.y)
    {
        pos.y -= box.y;
    }
    [branch] if(pos.y < 0.0)
    {
        pos.y += box.y;
    }
    [branch] if(pos.z > box.z)
    {
        pos.z -= box.z;
    }
    [branch] if(pos.z < 0.0)
    {
        pos.z += box.z;
    }

    return pos;
}


uint rotl(uint x, int k)
{
	return (x << k) | (x >> (32 - k));
}

uint s[4];

uint xorshift128plus()
{
    // Initialise rng seeder with some big primes
    s[0] = 27538393;
    s[1] = 88067389;
    s[2] = 67901627;
    s[3] = 36402433;

    rng_state = s[0] + s[3];
    uint t = s[1] << 9;

	s[2] ^= s[0];
	s[3] ^= s[1];
	s[1] ^= s[2];
	s[0] ^= s[3];

	s[2] ^= t;

	s[3] = rotl(s[3], 11);
    return rng_state;
}


uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}


float rand_float(uint id)
{
    rng_state = id;
	float tmp = (1.0 / 4294967296.0);
	return float(rand_xorshift()) * tmp;
}


[numthreads(THREAD_GROUPS,1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    Particle particle = particles[id.x];   
    
    
    float3 alignment = particle.velocity.xyz;
    // Compute alignments for each particle
    for (uint i = 0; i < (uint)numParticles; i++)
    {
        if (id.x != i)
        {
            Particle tempParticle = particles[i];
            float3 offset = tempParticle.position.xyz - particle.position.xyz;
            float dist = length(offset);
            if (dist < radius)
            {
                alignment += tempParticle.velocity.xyz;
            }
        }        
    }
    
    
    // particle.color = NoiseTexture.SampleLevel(samplerNoiseTexture, float2(600.0/1024, 2.0/1024.0), 0.0f).rgb;

    // Use time as seed for random float generator
    uint time_seed_1 = (uint)((time * 877) % numParticles);
    uint time_seed_2 = (uint)((time * 349) % numParticles);
    // Generate random floats
    float2 uvx = float2(rand_float(id.x + time_seed_1), rand_float(id.x + time_seed_2));
    // Use "random" floats to "randomly" sample noise texture
    float3 random_vector = NoiseTexture.SampleLevel(samplerNoiseTexture, uvx, 0.0f).rgb - 0.5;
    
    
    // Compute velocity based on alignment of neighbours and random vector
    float3 velocity = normalize(alignment) + random_vector*noise;

    // Give particle object new velocity and position 
    particle.velocity.xyz = velocity;
    particle.position.xyz += particle.velocity.xyz * speed * deltaTime;
    // Teleport agents from one end to box to other end
    particle.position.xyz = BoundToBox(particle.position.xyz);
    
    // Update buffer particle position and velocity
    particles[id.x] = particle;
}

// ----------------- Grid Update Code ------------------ //

uint CalcCellId(uint3 cell_xyz)
{
    uint X = cell_xyz.x;
    uint Y = cell_xyz.y;
    uint Z = cell_xyz.z;
    return X + grid_dims.x * Y + grid_dims.x * grid_dims.y * Z;
}


uint3 CalcCellCoords(float3 pos)
{
    float cell_dim = radius;
    // cell {0, 0, 0} is found at coordinate origin and has index 0
    uint cell_X = (uint) (pos.x / cell_dim);
    uint cell_Y = (uint) (pos.y / cell_dim);
    uint cell_Z = (uint) (pos.z / cell_dim);
    uint3 cell_xyz = {cell_X, cell_Y, cell_Z};

    return cell_xyz;
}


[numthreads(THREAD_GROUPS,1,1)]
void UpdateGrid (uint3 id : SV_DispatchThreadID)
{
    uint p_id = particle_ids[id.x];
    float3 pos = particles[p_id].position.xyz;
    uint3 cell_xyz = CalcCellCoords(pos);
    uint cell_id = CalcCellId(cell_xyz);
    grid_ids[p_id] = cell_id;
}