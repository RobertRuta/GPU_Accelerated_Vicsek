#pragma kernel CSParticle
#pragma kernel CSVicsek
#pragma kernel CSRandom

 // Particle's data
struct Particle
{
	float3 position;
	float3 velocity;
	float life;
};

// Particle's data, shared with the shader
RWStructuredBuffer<Particle> particleBuffer;
RWTexture2D<float4> noiseTexture;
RWStructuredBuffer<float3> randomBuffer;
// RWStructuredBuffer<float3> debugBuffer;

// Variables set from the CPU 
float deltaTime;
float time;
float2 mousePosition;
int particleCount;
float radius;

uint rng_state;

uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

float random_vec(uint id)
{
	rng_state = id;
	float tmp = (1.0 / 4294967296.0);
	float f0 = float(rand_xorshift()) * tmp - 0.5;
	float f1 = float(rand_xorshift()) * tmp - 0.5;
	float f2 = float(rand_xorshift()) * tmp - 0.5;
	float3 normalF3 = normalize(float3(f0, f1, f2)) * 0.8f;
	normalF3 *= float(rand_xorshift()) * tmp;

	return normalF3;
}

void respawn(uint id)
{
	rng_state = id;
	float tmp = (1.0 / 4294967296.0);
	float f0 = float(rand_xorshift()) * tmp - 0.5;
	float f1 = float(rand_xorshift()) * tmp - 0.5;
	float f2 = float(rand_xorshift()) * tmp - 0.5;
	float3 normalF3 = normalize(float3(f0, f1, f2)) * 0.8f;
	normalF3 *= float(rand_xorshift()) * tmp;
	particleBuffer[id].position = float3(normalF3.x + mousePosition.x, normalF3.y + mousePosition.y, normalF3.z + 3.0);
	// reset the life of this particle
	particleBuffer[id].life = 4;
	particleBuffer[id].velocity = float3(0,0,0);
}

[numthreads(256, 1, 1)]
void CSParticle(uint3 id : SV_DispatchThreadID)
{
	Particle particle = particleBuffer[id.x];
	// subtract the life based on deltaTime
	particle.life -= deltaTime;

	float3 delta = float3(mousePosition.xy, 3) - particle.position;
	float3 dir = normalize(delta);

	particle.velocity += dir;
	particle.position += particle.velocity * deltaTime;

	particleBuffer[id.x] = particle;
	
	if (particle.life < 0) respawn(id.x);
}


[numthreads(256, 1, 1)]
void CSVicsek(uint3 id : SV_DispatchThreadID)
{
	Particle particle = particleBuffer[id.x];
	float3 alignment = particle.velocity;

	for (int i = 0; i < particleCount; i++)
	{
		if (i != id.x)
		{
			Particle tempParticle = particleBuffer[i];
			float3 offset = particle.position - tempParticle.position;
			if (length(offset) < radius)
			{
				alignment += tempParticle.velocity;
			}
		}
	}

	// float3 error = float3((uint)(time*1000), (uint)(time*1000), (uint)(time*1000));
	// float3 error = random_vec((uint)(time*1000));
	particle.velocity = normalize(alignment);
	// particle.velocity = float3(1,1,1);
	particle.position += particle.velocity * deltaTime;
	// particle.position = error;

	int2 pixel_id = int2(id.x, 0);
	if (noiseTexture[pixel_id].r > 0.5)
	{
		particle.position = float3(0,0,0);
	}
	particleBuffer[id.x] = particle;
	// // subtract the life based on deltaTime
	// particle.life -= deltaTime;

	// float3 delta = float3(mousePosition.xy, 3) - particle.position;
	// float3 dir = normalize(delta);

	// particle.velocity += dir;
	// particle.position += particle.velocity * deltaTime;

	// particleBuffer[id.x] = particle;
	
	// if (particle.life < 0) respawn(id.x);
}

[numthreads(128, 128, 1)]
void CSRandom(uint3 id : SV_DispatchThreadID)
{
	int2 seed = int2((time * 1000 * id.x) % 512, (time * 1000 * id.y) % 512);
	float4 pixel = noiseTexture[id.xy];

	int index = id.x + id.y*512;
	randomBuffer[index] = float3(pixel.x, pixel.y, pixel.z);
}