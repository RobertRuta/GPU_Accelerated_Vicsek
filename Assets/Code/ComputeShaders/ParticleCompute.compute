// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel ParticleUpdate
#pragma kernel OptimizedParticleUpdate
#pragma kernel RearrangeParticleIDs
#pragma kernel BuildStartEndIDs
#pragma kernel ResetCellBuffer


#include "noise_utility.cginc"
#include "xorshiro.cginc"
#include "grid_utility.cginc"


struct Particle
{
    float4 position;
    float4 velocity;
};

struct Cell
{
    int count;
};


RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<float3> positionBuffer;
RWStructuredBuffer<Cell> cellBuffer;
RWStructuredBuffer<uint> cellIDs;
RWStructuredBuffer<uint> particleIDs;
RWStructuredBuffer<uint> keys;
RWStructuredBuffer<uint2> startendIDs;
RWStructuredBuffer<float4> debugBuffer;
RWStructuredBuffer<float4> debugBuffer2;
RWStructuredBuffer<float4> debugBuffer3;

Texture2D NoiseTexture;
SamplerState samplerNoiseTexture;



[numthreads(128,1,1)]
void ParticleUpdate (uint3 id : SV_DispatchThreadID)
{
    Particle particle = particleBuffer[id.x];

    float3 summed_velocity = float3(0,0,0);
    // Loop through every other particle in the simulation
    for (int i=0; i<particle_count; i++)
    {
        Particle neighbour = particleBuffer[i];

        float distance = length(neighbour.position.xyz - particle.position.xyz);
        if (distance < radius)
        {
            summed_velocity += neighbour.velocity.xyz;
        }
    }
    float3 new_velocity = normalize(summed_velocity) * speed;

    // particle.velocity.xyz = float3(0,1,0);
    particle.velocity.xyz = new_velocity;
    particle.position.xyz += particle.velocity.xyz*dt;
    particle.position.w = particleSize;

    BoundToBox(particle.position.xyz);
    particleBuffer[id.x] = particle;
}



[numthreads(128,1,1)]
void OptimizedParticleUpdate (uint3 id : SV_DispatchThreadID)
{
    uint p_id = particleIDs[id.x];
    Particle particle = particleBuffer[p_id];
    int3 cell_pos = CalcCellCoords(particle.position.xyz);
    uint cell_id = CalcCellId(cell_pos);


    ////////// ------ SUM NEIGHBOUR VELOCITIES ------ ////////// 
    
    float3 init_velocity = particle.velocity.xyz;
    float3 summed_velocity = particle.velocity.xyz;
    int neighbour_counter = 0;
    // Loop through neighbouring cells
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            for (int z = -1; z <= 1; z++) {
                // Compute neighbour cell coordinates
                int3 neighbouring_cell_pos = cell_pos + int3(x, y, z);
                neighbouring_cell_pos = int3(
                    (neighbouring_cell_pos.x + grid_dims.x) % grid_dims.x,
                    (neighbouring_cell_pos.y + grid_dims.y) % grid_dims.y,
                    (neighbouring_cell_pos.z + grid_dims.z) % grid_dims.z
                );
                // Compute neighbour cell id from cell coordinates
                uint neighbour_cell_id = CalcCellId(neighbouring_cell_pos);
                // If neighbour cell is not empty
                if (cellBuffer[neighbour_cell_id].count > 0)
                {
                    uint start_id = startendIDs[neighbour_cell_id].x;
                    uint end_id = startendIDs[neighbour_cell_id].y;
                    if (end_id > start_id)
                    {
                        // Loop through particles in neighbouring cell
                        for (uint i = start_id; i <= end_id; i++)
                        {
                            uint neighbour_id = particleIDs[i];
                            Particle neighbour = particleBuffer[neighbour_id];
                            float distance = length(neighbour.position.xyz - particle.position.xyz);
                            if (distance < radius) {
                                summed_velocity += neighbour.velocity.xyz;
                                neighbour_counter++;
                            }
                        }
                    }
                }
            }
        }
    }
    // Average neighbour direction is the normalized sum of neighbour velocities
    float3 average_direction = normalize(summed_velocity);
    float3 average_velocity = average_direction * speed;

    
    ////////// ------ RANDOM NUMBER GENERATION ------ //////////
    uint time_seed = (uint)(time*1000);
    uint time_seed_2 = MurmurHash3(time_seed);
    uint particle_seed = MurmurHash3(p_id+1);
    uint particle_seed2 = MurmurHash3(particle_seed);
    uint time_particle_seed = MurmurHash3(particle_seed + time_seed_2);
    uint time_particle_seed2 = MurmurHash3(particle_seed2 + time_seed);
    uint cell_seed = rotl(time_seed, cell_id);
    
    float3 random_vector = hash(uint3(time_seed_2, particle_seed, cell_seed));
    // random_vector = normalize((random_vector - 0.5) * 2);

    // normal_vector = normalize(cross(average_direction, random_vector));
    // normal_vector = float3(1,0,0);
    float3 other_vector = GetOtherVector(average_direction);
    float3 normal_vector = cross(other_vector, average_direction);
    float angle1 = (float)time_particle_seed / (float)0xffffffff * PI * noise; // Random angle
    float angle2 = (float)time_particle_seed2 / (float)0xffffffff * PI * 2; // Random angle
    float3 new_direction = RodriguezRot(average_direction, normal_vector, angle1);
    new_direction = RodriguezRot(new_direction, average_direction, angle2);

    // float3 new_direction = float3(1,1,1);



    // state = id.x ^ time_seed_1;
    // if (state == 0) state = time_seed_2;


    // float3 random_vector = hash(uint3(state, id.x, frame_counter)) - 0.5;
    // float3 u_rand = hash(uint3(p_id, id.x^time_seed_2, frame_counter));
    // float3 u_rand2 = hash(uint3(state, id.x, frame_counter));
    // float2 n_rand = box_muller_normal_random(u_rand.x, u_rand2.x);
    // float2 n_rand2 = box_muller_normal_random(u_rand.y, u_rand2.y);

    
    // box_muller_normal_random();

    // float3 random_unit_vector = normalize(float3(n_rand.x, n_rand.y, n_rand2.x));
    // float3 random_unit_vector = normalize(random_vector);
    // float3 random_unit_vector = random_vector;

    ////////// ------ UPDATE PARTICLE POSITION AND VELOCITY ------ //////////
    float3 new_velocity = new_direction * speed;
    // float3 new_velocity = normalize(summed_velocity + noise*neighbour_counter*random_unit_vector*speed) * speed;
    // float3 new_velocity = normalize(summed_velocity) + random_unit_vector * speed;

    particle.velocity.xyz = new_velocity;
    particle.position.xyz += particle.velocity.xyz*dt;    
    // Enforce Periodic Boundaries
    BoundToBox(particle.position.xyz);
    // Update particle in buffer
    particleBuffer[p_id] = particle;
    // Update particle size;
    particleBuffer[p_id].position.w = particleSize;


    ////////// ------ UPDATE GRID ------ //////////

    cell_pos = CalcCellCoords(particle.position.xyz);
    cell_id = CalcCellId(cell_pos);
    cellIDs[p_id] = cell_id;


    
    
    ////////// ------ DEBUG BUFFER ------ //////////

    // debugBuffer[id.x].xyzw = float4(rand_float_1, rand_float_2, rand_float_3, rand_float_4);
    // debugBuffer[id.x].xyz = float3(rand_norm_1, rand_norm_2, rand_norm_3);
    // debugBuffer[id.x].xyz = random_unit_vector;
    // debugBuffer[id.x].xyz = ;
    // debugBuffer[id.x] = float4(average_direction, particle_seed);
    // float3 crossed_rand = cross(random_vector, init_velocity);
    // debugBuffer[id.x] = float4(average_direction, 0);
    // debugBuffer2[id.x] = float4(particle.position);
    // debugBuffer3[id.x] = float4(normal_vector, angle);
    // float2 startend_debug = float2(startendIDs[id.x]);
    debugBuffer[id.x] = float4(p_id, particle.position.xyz);
    debugBuffer2[id.x] = float4(angle1, random_vector);
    debugBuffer3[id.x] = float4(angle1, normal_vector);
    // debugBuffer[id.x] = float4(id.x, cellBuffer[id.x].count, startend_debug);
    // // debugBuffer3[id.x] = float4(p_id, cell_id, cellIDs[id.x], cellIDs[p_id]);
    // debugBuffer3[id.x] = float4(0, startendIDs[cellIDs[0]].x, startendIDs[cellIDs[0]].y, -1);
  
  
    // Reset cell buffer - temporarily moved after debug buffer
    // cellBuffer[cell_id].count = 0;
}



[numthreads(128,1,1)]
void RearrangeParticleIDs (uint3 id : SV_DispatchThreadID)
{
    particleIDs[id.x] = keys[id.x];
    keys[id.x] = id.x;
}



[numthreads(128,1,1)]
void BuildStartEndIDs (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    uint p_id = particleIDs[i];
    uint cell_id = cellIDs[p_id];
    uint prev_cell_id = (i != 0) ? cellIDs[particleIDs[i-1]] : cellIDs[particleIDs[(uint)particle_count-1]];
    uint next_cell_id = (i != (uint)particle_count-1) ? cellIDs[particleIDs[i+1]] : cellIDs[particleIDs[0]];
    
    // For some reason this breaks for the cell with p_id == 0 ...
    if (p_id != 0) {
        if (cell_id != prev_cell_id)
            startendIDs[cell_id].x = i;
        if (cell_id != next_cell_id)
            startendIDs[cell_id].y = i;

        // Specify which cells have particles
        cellBuffer[cell_id].count++;
    }
    // ... this is why this else statement is necessary
    else {
        startendIDs[cell_id].x = startendIDs[cell_id - 1].y + 1;
        if (cell_id != next_cell_id)
            startendIDs[cell_id].y = i;
    }
}



[numthreads(128,1,1)]
void ResetCellBuffer (uint3 id : SV_DispatchThreadID)
{
    cellBuffer[id.x].count = 0;
}