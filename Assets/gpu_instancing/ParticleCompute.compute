// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ParticleUpdate
#pragma kernel RearrangeParticles
#pragma kernel BuildStartEndIDs

struct Particle
{
    float4 position;
    float4 velocity;
};

RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<uint> cellIDs;
RWStructuredBuffer<uint> particleIDs;
RWStructuredBuffer<uint> keys;
RWStructuredBuffer<uint2> startendIDs;

float dt;
int particle_count;
float radius;
float speed;
float3 box;
uint3 grid_dims;



void BoundToBox(inout float3 pos)
{
    if(pos.x > box.x)
    {
       pos.x -= box.x;
    }
    if(pos.x < 0.0)
    {
        pos.x += box.x;
    }
    if(pos.y > box.y)
    {
        pos.y -= box.y;
    }
    if(pos.y < 0.0)
    {
        pos.y += box.y;
    }
    if(pos.z > box.z)
    {
        pos.z -= box.z;
    }
    if(pos.z < 0.0)
    {
        pos.z += box.z;
    }

    // return pos;
}


uint CalcCellId(uint3 cell_xyz)
{
    uint X = cell_xyz.x;
    uint Y = cell_xyz.y;
    uint Z = cell_xyz.z;
    return X + grid_dims.x * Y + grid_dims.x * grid_dims.y * Z;
}

uint3 CalcCellCoords(float3 pos)
{
    float cell_dim = radius;
    // cell {0, 0, 0} is found at coordinate origin and has index 0
    uint cell_X = (uint) (pos.x / cell_dim);
    uint cell_Y = (uint) (pos.y / cell_dim);
    uint cell_Z = (uint) (pos.z / cell_dim);
    uint3 cell_xyz = {cell_X, cell_Y, cell_Z};

    return cell_xyz;
}


[numthreads(128,1,1)]
void ParticleUpdate (uint3 id : SV_DispatchThreadID)
{
    uint pID = particleIDs[id.x];
    Particle particle = particleBuffer[pID];

    float3 summed_velocity = float3(0,0,0);
    // Loop through every other particle in the simulation
    for (int i=0; i<particle_count; i++)
    {
        Particle neighbour = particleBuffer[i];

        float distance = length(neighbour.position.xyz - particle.position.xyz);
        if (distance < radius)
        {
            summed_velocity += neighbour.velocity;
        }
    }
    float3 new_velocity = normalize(summed_velocity) * speed;

    // particle.velocity.xyz = float3(0,1,0);
    particle.velocity.xyz = new_velocity;
    particle.position.xyz += particle.velocity.xyz*dt;

    BoundToBox(particle.position.xyz);
    particleBuffer[pID] = particle;


    // // Grid Update
    // uint3 cell_pos = CalcCellCoords(particle.position.xyz);
    // uint cell_id = CalcCellId(cell_pos);
    // cellIDs[pID] = cell_id;
}



[numthreads(128,1,1)]
void RearrangeParticles (uint3 id : SV_DispatchThreadID)
{
    particleIDs[id.x] = particleIDs[keys[id.x]];
    keys[id.x] = id.x;
}


[numthreads(128,1,1)]
void BuildStartEndIDs (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    uint p_id = particleIDs[i];
    uint current = cellIDs[p_id];
    uint prev = (i != 0) ? cellIDs[particleIDs[i-1]] : cellIDs[particleIDs[particle_count-1]];
    uint next = (i != particle_count-1) ? cellIDs[particleIDs[i+1]] : cellIDs[particleIDs[0]];

    if (current != prev)
        startendIDs[current].x = i;
    if (current != next)
        startendIDs[current].y = i;
}